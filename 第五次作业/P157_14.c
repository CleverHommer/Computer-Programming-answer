//思路：利用地址形参实现函数直接对待排序数组做改动
#include<stdio.h>
void sort(int* a,int n){//没有必要返回任何值的函数就设置为void类型
    for(int i=1;i<n;i++){
        int t=a[i],j=0;
        for(;j<i;j++){
            if(a[j]<t) break;
        }//这个循环也可以写成for(;a[j]<t;j++); 想想为什么？
        for(int k=i-1;k>=j;--k){//写循环一定要注意终止条件，想想为什么是k>=j不是k>j?
            a[k+1]=a[k];
        }
        a[j]=t;
    }
    return;
}
int main(){
    int a[10]={1,2,3,99,45,32,193};//图方便直接内置值，写成从键盘输入也很好
    sort(a,7);
    for(int i=0;i<6;++i) printf("%d ",a[i]);
    printf("%d\n",a[6]);//最后一个值后面不输出空格而是输出回车，适用于要求数值后不能有多余空格且要求最后一个字符为回车的机器批改
    return 0;
}
/*
有同学对程序的时间复杂度这一概念不大了解，这里作简单的介绍，有兴趣的同学可以进一步与助教交流或查询网络资料。
时间复杂度是算法执行时间关于问题规模的函数，它体现了该算法处理问题耗时随问题规模变大的变化趋势。
计算（或者说估算，因为我们后面就会看到我们实际上并不关注也没法得到这个函数的具体表达式，我们只考虑最大的若干项）时间复杂度基于以下假设：
0. 程序是可以在有限时间内结束的。（序号0表示这是一切的前提，后面的123...都是并列关系，但这条跟他们不并列）
1. 基础运算（如加减乘除，关系运算）消耗的时间是常数量级，即我们忽略参与运算的数字变大导致的基础运算用时延长。
2. 程序能够处理大规模的问题，因而常数相对于问题的规模n来说是可以忽略的。（比如我们认为2n和n是一样大的）
3. 一般来说时间复杂度指的是算法在不同情况下的平均耗时，如果专门考虑最优（或最差）情况我们会专门称其为最优（最差）情况下的时间复杂度
以上述的程序为例，赋n个初值（或者读入n个值）需要n次运算，因而时间复杂度为O(n)（这个记号表示处理问题的时间是n量级）
而后续的排序过程需要对n个值做双循环，第一个循环从1到n-1,第二个从0到i-1，又从i-1到某个j，因而最多需要2*(1+2+...+n)=n*(n+1)次操作
但我们前面假设，常数对于n来说是可以忽略的，因此这里的时间复杂度是O(n^2)
后面输出的时间复杂度同样为O(n),总计时间复杂度是O(n^2+2n).但我们只考虑最大的项，从而总时间复杂度是O(n^2).
*/